# Big O 표기의 필요성
한 문제에 대해 여러개의 접근법이 있을 때, 단순히 보는 것 만으로 어떤 방법이 더 좋은지 알 수 없기 때문에, Big O 표기법을 사용하면 숫자로 코드의 성능을 표기할 수 있다.  
단순 시간 비교는 기기마다 사양이 틀리기 때문에 완전히 신뢰성이 있다고 할 수 없다. 그리고 같은 기기일지라도 그때그때의 상황에 따라 소요되는 시간이 다를 수 있다.  
그렇기 때문에 `컴퓨터가 연산해야 하는 개수` 를 계산하는 것이 바로 Big O 표기의 기본 원리이다.  

## n의 크기에 따른 차이
기본적으로는 n의 크기가 커질수록, 더 많은 시간이 걸린다고 볼 수 있다.  
하지만 몇몇 규칙에 따라, 단순화가 가능하다.  

## 식의 단순화
1. n에 몇이 곱해지든, 그 수는 중요하지 않다.  
어차피 n이 커지면 커질수록 몇을 곱하든 그 크기에 큰 차이가 없기 때문이다.  
`ex) O(2n) --> O(n), O(13n`<sup>`2`</sup>`) --> O(n`<sup>`2`</sup>`)`


2. 상수는 의미가 없다.  
위와 마찬가지로 n이 커질수록 상수는 큰 영향을 끼치지 못하기 때문이다.  
`ex) O(500) --> O(1), O(n+2) --> O(n)`  

3. 위 두개를 합쳐서도 가능  
`ex) O(1000n + 300) --> O(n)`  

4. n의 제곱수가 있다면, 가장 큰 제곱수만 중요하다.  
n이 커질수록 작은 제곱수의 n은 의미가 없어진다.  
`ex) O(n`<sup>`2`</sup>` + 5n + 8) --> O(n`<sup>`2`</sup>`)`

## Big O 규칙 (항상 맞진 않음)
1. 산수는 상수이다. 덧셈, 뺄셈, 곱셈, 나눗셈 포함.  
1000000+2 와 2+2 는 결국 컴퓨터에서 처리하는 시간이 비슷하다.

2. 변수 배정도 산수이다.  
변수에 값을 배정하는 시간은 비슷하기 때문에, x=1000 이든 x=1000000 이든 비슷하다.  

3. 인덱스를 이용해 배열 혹은 객체에 접근하는 것도 상수이다.  

4. 루프 안에서는 시간 복잡도가 루프의 길이 X 루프 내의 연산의 시간복잡도 이다.